======================================================================================================================
DESCRIPTION:

analysis.lami: correctly handle Number (double, long etc.) type graphing

LTTng analysis return mostly long values either for the time stamps or actual
measurements. SWTChart, on the other hand, deal only with "double" numerical
values. Casting long to double causes a loss of precision for big long value
(e.g time stamps).

E.g:
Loss of precision occurs when time ranges with a big minimal value (2^62) but
with little delta (1 ns) between events exist. Graph generated from such time
ranges as an axis would result in a single dot which is a clear problem.

The presented solution uses linear mapping to preserve resolution
and precision when possible.

The linear mapping requires two ranges: the internal range and the external
range.

Each graph is responsible to provide an internal LamiGraphRange. This range is
the internal representation in double in which all raw (external) value are to
be mapped. For now the default internal range is 0 to 1.

The external range [raw values range] is generated by finding the minimal value
and maximal values of aspects to be plotted.

Each point is then mapped to corresponding value from the internal range:

internalValue = (( externalValue - externalRange.minimum ) * ( internalRange.delta / external.delta )) + internalRange.minimum

Since the default internal range is from 0 to 1 al raw values are mapped to a
value from 0 to 1.

On graph tick generation axis formatter transform internal representation to
external representation and format the result.

Other change:
- Aspects now return their numerical values via resolveNumber to ensure no casting
is done.
- Move axis formatter to ui plugin.

Bug: 493941

Change-Id: I289180e10a7f1cbf6ecdd1beba93549b8fbe4c23
Signed-off-by: Jonathan Rajotte <jonathan.rajotte-julien@efficios.com>

======================================================================================================================
COMMENTS
======================================================================================================================
Author: CI Bot
Date: 2016-05-24 22:57:57.000000000
Message: 
Patch Set 7:

Build Started https://hudson.eclipse.org/tracecompass/job/tracecompass-gerrit/8653/
----------------------------------------------------------------------------------------------------------------------
Author: Jonathan Rajotte Julien
Date: 2016-05-24 22:59:26.000000000
Message: 
Patch Set 7: Code-Review-1

(1 comment)
Line:22, analysis/org.eclipse.tracecompass.analysis.lami.core.tests/src/org/eclipse/tracecompass/analysis/lami/core/tests/LamiJsonParserTest.java -> Rebase trash ... will rebase correctly

----------------------------------------------------------------------------------------------------------------------
Author: CI Bot
Date: 2016-05-24 23:40:28.000000000
Message: 
Patch Set 7: Code-Review+1

Build Successful 

https://hudson.eclipse.org/tracecompass/job/tracecompass-gerrit/8653/ : SUCCESS
----------------------------------------------------------------------------------------------------------------------
Author: Jonathan Rajotte Julien
Date: 2016-05-25 12:57:14.000000000
Message: 
Patch Set 7: -Code-Review

Finally the rebase was ok.
----------------------------------------------------------------------------------------------------------------------
Author: Patrick Tasse
Date: 2016-05-25 14:59:56.000000000
Message: 
Patch Set 7: Code-Review-1

(3 comments)
Line:137, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/format/LamiDecimalUnitFormat.java -> If you want, you could merge the two if-blocks.

Line:137, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/format/LamiTimeStampFormat.java -> If you want, you could merge the two if-blocks.

Line:769, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> I observed the following:

- We want to use the clamped range so that the internal value calculation has the best possible floating-point precision. This is important for timestamps but could be valid for any other kind of numbers.

- If we don't consider the above, the external range we compute does not matter as the actual chart range, it gets modified in all cases by the call to getAxisSet().adjustRange() to a range that best fits the actual data.

- An exception to the above is if the initially provided range has a delta of zero, then adjustRange() does not seem to modify anything and you get all ticks with the same label. That is if you remove the setting of minimum to zero and let it use the real min and max. I observed it with non-timestamp values (commenting out line 768), but I'm afraid it could happen with timestamps with the existing code if they are all the same (or if there is a single data point).

So I wonder if we should not always clamp to min and max, with the exception where min and max are the same, then you just make sure the range delta is non-zero while keeping min and/or max in the same order of magnitude, and do this regardless of whether it is a timestamp or not.

----------------------------------------------------------------------------------------------------------------------
Author: Jonathan Rajotte Julien
Date: 2016-05-25 19:23:03.000000000
Message: 
Patch Set 7:

(2 comments)
Line:137, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/format/LamiTimeStampFormat.java -> Hmm I think I would like to keep the handling separate since it looks clearer to me. Your call.

Line:769, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> The reason for clamping to 0 or <0 is simply for the bar chart and the lack of intelligence of swtchart on generating good range. It make no sense to have a bar chart start at 0.0001s instead of zero.

e.g: http://i.imgur.com/AcpPgWB.png

In the end this is a "it work for most of what we want to do" solution.

I did have some fun in libreOffice Calc to check how they do it. On a bar chart the axis always include zero by default (you can override the axis min value) on a scatter chart it depend on the data and relation between max and min.

 if( bAutoMinimum && (fTempMinimum > 0.0) )
 {
     /*  If minimum equals maximum, or if minimum is less than 5/6 of
         maximum, set minimum to 0. */
     if( (fTempMinimum == fTempMaximum) || (fTempMinimum / fTempMaximum < 5.0 / 6.0) )
      {
         if( m_bExpandWideValuesToZero )
             fTempMinimum = 0.0;
     }
     /*  Else (minimum is greater than or equal to 5/6 of maximum), add half
         of the visible range (expand minimum toward 0) to make the
         'shorter' data points visible. */
     else
     {
         if( m_bExpandNarrowValuesTowardZero )
             fTempMinimum -= (fTempMaximum - fTempMinimum) / 2.0;
     }
 }

This could be an alternative when the apsect being plotted is not a timestamp/category.

What do you think ?

----------------------------------------------------------------------------------------------------------------------
Author: Patrick Tasse
Date: 2016-05-25 20:03:39.000000000
Message: 
Patch Set 7:

(2 comments)
Line:137, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/format/LamiTimeStampFormat.java -> Haha then it's code clarity vs code duplication and Sonar only checks the latter...

I don't mind, but to me it seems just as clear to say, if either range is zero skip the calculation.

Line:769, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> Oh I see, I had tested with scatter chart only.

The bar chart doesn't modify the y range when we do adjustRange() like scatter chart does, is that a particularity of bar charts in SWTChart, or is it due to something you set in your code?

What I would propose then is for the bar chart to clamp only the x-axis and not the y-axis, the loss of precision will be indistinguishable with a range between 0 and a large value given the number of pixels. For the scatter chart I would always clamp. And in all cases I would not allow for a range with zero delta.

----------------------------------------------------------------------------------------------------------------------
Author: Jonathan Rajotte Julien
Date: 2016-05-25 20:37:05.000000000
Message: 
Patch Set 7:

(2 comments)
Line:137, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/format/LamiTimeStampFormat.java -> let's merge them then !

Line:769, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> Oh I see, I had tested with scatter chart only.
    The bar chart doesn't modify the y range when we do 
    adjustRange() like scatter chart does, is that a    
    particularity of bar charts in SWTChart, or is it due to   
    something you set in your code?

We call adjustRange globally one time so it is SWTchart adjust range that does not account correctly (might be a side effect of something but I could not pinpoint it).

 
    What I would propose then is for the bar chart to clamp   
    only the x-axis and not the y-axis, the loss of precision   
    will be indistinguishable with a range between 0 and a 
    large value given the number of pixels.

Did you wanted to say to clamp y-axis only (the only axis that make sense to clamp on a bar chart since x axis are categories)? There is no guaranteed that we deal with big number here...


    For the scatter 
    chart I would always clamp. And in all cases I would not    
    allow for a range with zero delta.

Zero delta simply mean one plotting tuple in a scatter chart (min=max for both axis) and similar y value for all value in a bar chart (min = max for y on all x[category]). Forbidding it would be weird.

I'm more interested in following the way libre office does it  and plan on going this route if you do not have any strong objection.

For a scatter chart: 
if min < 0 
   -> set range minimum to min
else
    if min < 5/6 of max value 
         -> set range minimum to zero
    else -> 
         -> set range minimum to min

For a bar chart:
if min < 0 
   -> set range minimum to min
else
   -> set range minimum to zero

----------------------------------------------------------------------------------------------------------------------
Author: Patrick Tasse
Date: 2016-05-26 15:46:12.000000000
Message: 
Patch Set 7:

(1 comment)
Line:769, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> > We call adjustRange globally one time so it is SWTchart adjust range that does not account correctly (might be a side effect of something but I could not pinpoint it).

OK after further testing it seems the initial external range has some effect on the outcome of adjustRange(). But the effect is hard to predict without looking at the source code.

If all your data points are <2.0, 2,0>, then in most cases the outcome is [1.0, 3.0] (including when the initial range is [0.0, 2,0]). But with initial range of [-10.0, 10.0] the outcome is [-4.0, 8.0].

> Did you wanted to say to clamp y-axis only (the only axis that make sense to clamp on a bar chart since x axis are categories)? There is no guaranteed that we deal with big number here...

Oh right, x-axis has no range for bar charts. So I meant that y-axis range is [0.0, max] (or [min, max] if min is negative). For scatter chart I would always use [min,max]. With the exception below.

> Zero delta simply mean one plotting tuple in a scatter chart (min=max for both axis) and similar y value for all value in a bar chart (min = max for y on all x[category]). Forbidding it would be weird.

I don't mean the the value(s) should be allowed but that the range should be extend slightly to not be zero.

Here is what I meant with this whole discussion:

If you are plotting very large numbers (that are not timestamps), if you set the range to [0.0, max] then you have a loss of precision. You can have just a few very close large number but the ticks are for example 0.2G apart... That is why I suggest to always use [min, max] for both scatter axis.

The only problem with that is that if there is only one value, and the range is [val, val], then the axis ticks after adjustment will all be val, ex: 2, 2, 2, 2, etc.

So that is why I proposed to not allow a range of [val, val] but instead change that exceptional case to something like [val-1, val+1] or [val*0.9, val*1.1].

But now I test that and I realize that the tick label formatting has only one decimal precision so even if the large numbers are plotted correctly with great precision the tick labels are all 1.3G, 1.3G, 1.3G, etc... So the loss of precision would not be so noticeable after all (unless you really examine closely the data pixel locations).

So, in conclusion, the only noticeable problem with the current solution is that if there is a single value and that single value is zero or negative, the axis ticks will be 0, 0, 0, 0 or -2, -2, -2, -2 etc.

----------------------------------------------------------------------------------------------------------------------
Author: Jonathan Rajotte Julien
Date: 2016-05-26 16:13:15.000000000
Message: 
Patch Set 7:

(1 comment)
Line:769, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> The current solution being the one right now (code wise) ?

>The only problem with that is that if there is only one value, 
>and the range is [val, val], then the axis ticks after 
>adjustment will all be val, ex: 2, 2, 2, 2, etc.

This is the case where setting the range to 1 in the tick formatter did make sense but we concluded it was not the place to do so.

----------------------------------------------------------------------------------------------------------------------
Author: Patrick Tasse
Date: 2016-05-26 17:52:32.000000000
Message: 
Patch Set 7:

(3 comments)
Line:752, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> typo?

Line:767, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> I don't know what you think, but I feel it would be clearer if the default behavior would be to use [min,max] as the range, but on request (e.g. for the bar chart y-axis) the user would ask to clamp to zero instead?

Line:769, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> Ahh I see what's happening...

Let's say all values are 2.0. Internal range is always [0.0, 1.0]. And if we clamp external range is [2.0, 2.0].

Internally all data values of 2.0 map to internal 0.0.

When we do adjustRange() SWTChart changes the internal range from [0.0, 1.0] to [-1.0, 1.0], and spreads this out for all the ticks. But with the change I asked you to do in the formatter, all the tick values between [-1.0, 1.0] map to 2.0 before formatting because that is the external range minimal value (and the external range delta is zero).

So I think it boils down to the fact that external range delta should never be allowed to be zero. We can ensure this here.

If all values are 2.0, and internal range is [0.0, 1.0], and 2.0 maps to 0.0 internally (internal minimal), then external minimal should be 2.0 but external maximal should be something bigger. I suggest (min + 1)?

After adjustment, the middle tick will be the external minimal (a.k.a the sole value), and the top tick will be the external maximal. So we can play with the external maximal if we want to see a specific range of ticks for that case.

I added these lines here, it seems to fix the issue:

        if (max.equals(min)) {
            max = min.add(new BigDecimal(1));
        }

----------------------------------------------------------------------------------------------------------------------
Author: Jonathan Rajotte Julien
Date: 2016-05-27 15:08:13.000000000
Message: 
Patch Set 8: Patch Set 7 was rebased
----------------------------------------------------------------------------------------------------------------------
Author: Jonathan Rajotte Julien
Date: 2016-05-27 17:43:30.000000000
Message: 
Patch Set 7:

(2 comments)
Line:767, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> Done

I also changed the name of this variable to

clampToZeroOrNegativeMinimum 

Looks go to you ?

Line:769, analysis/org.eclipse.tracecompass.analysis.lami.ui/src/org/eclipse/tracecompass/internal/provisional/analysis/lami/ui/viewers/LamiXYChartViewer.java -> +1

Done

----------------------------------------------------------------------------------------------------------------------
Author: Gerrit Code Review
Date: 2016-05-31 22:54:06.000000000
Message: 
Change has been successfully cherry-picked as 5b973e7c65f168e79139fdc0045dda56ff71f650 by Alexandre Montplaisir
----------------------------------------------------------------------------------------------------------------------

======================================================================================================================
DESCRIPTION:

analysis: Correctly track the state of scheduled-out processes

On a sched_switch, the state of a the process going out should not
always be WAIT_BLOCKED (the yellow state in the CFV). If the prev_state
field indicates 0 (TASK_RUNNING), it means the process was scheduled
out due to preemption, not to being blocked on something. In those
cases, we should put the process into the WAIT_FOR_CPU state.

Bug: 477052
Change-Id: Ic181811c11029d6374a5e65149a103febd25b5ea
Signed-off-by: Alexandre Montplaisir <alexmonthy@voxpopuli.im>
Reviewed-on: https://git.eclipse.org/r/55770
Reviewed-by: Hudson CI
Reviewed-by: Bernd Hufmann <bernd.hufmann@ericsson.com>

======================================================================================================================
COMMENTS
======================================================================================================================
Author: Gerrit Code Review
Date: 2015-09-16 22:44:51.000000000
Message: 
Change has been successfully cherry-picked as 2f693965b8d4699cc768d7af2ca7f63d366023af by Alexandre Montplaisir
----------------------------------------------------------------------------------------------------------------------
Author: Bernd Hufmann
Date: 2015-09-17 12:55:42.000000000
Message: 
Patch Set 2:

> Any kernel trace with some CPU contention makes it easy to try, for
 > example a trace generated by https://github.com/tracecompass/xml-analysis-example
 > . If there is a sched_switch where the prev_state field is 0, it
 > means the task going out still wants to run, in which case it
 > should be WAIT_FOR_CPU (orange) and not WAIT_BLOCKED (yellow).

Maybe I miss something, but I don't see a difference. I created a trace with your program and searched for sched_switch and prev_state=0. The old code and new code does the same. In the old code if prev_state == 0 it's always wait for CPU (else path below). Could you please give some more insights?

 if (prevState != LinuxValues.TASK_STATE_RUNNING) {
                    if (prevState == LinuxValues.TASK_STATE_DEAD) {
                        value = TmfStateValue.nullValue();
                    } else {
                        value = StateValues.PROCESS_STATUS_WAIT_BLOCKED_VALUE;
                    }
                } else {
                    value = StateValues.PROCESS_STATUS_WAIT_FOR_CPU_VALUE;
                }
----------------------------------------------------------------------------------------------------------------------
Author: Alexandre Montplaisir
Date: 2015-09-18 16:14:59.000000000
Message: 
Patch Set 2:

You're right, this particular patch did not really affect the behaviour (other than using the "UNKNOWN" state for unexpected values).

But as bug 477052 mentioned, recent kernel versions sometimes use the "STATE_MAX" value. This was taken care of by the patch previous to this one. We've tried a couple scenarios on our side, and everything seemed fine.
----------------------------------------------------------------------------------------------------------------------

======================================================================================================================
DESCRIPTION:

tmf: Support hexadecimal and octal formats in numerical compare filter

Also, all cases where a comparison cannot be performed no longer match
the filter regardless of the NOT flag, since the NOT flag can be used to
indicate <=, != and >= comparisons.

Change-Id: I2a94b9e32744d05bfdfdba7df32137390bbb27d2
Signed-off-by: Patrick Tasse <patrick.tasse@gmail.com>
======================================================================================================================
COMMENTS
======================================================================================================================
Author: Patrick Tasse
Date: 2015-01-14 19:47:34.000000000
Message: 
Uploaded patch set 3.
----------------------------------------------------------------------------------------------------------------------
Author: CI Bot
Date: 2015-01-14 20:05:39.000000000
Message: 
Patch Set 3:

Build Started https://hudson.eclipse.org/tracecompass/job/tracecompass-gerrit/847/
----------------------------------------------------------------------------------------------------------------------
Author: CI Bot
Date: 2015-01-14 20:39:33.000000000
Message: 
Patch Set 3: Code-Review+1

Build Successful 

https://hudson.eclipse.org/tracecompass/job/tracecompass-gerrit/847/ : SUCCESS
----------------------------------------------------------------------------------------------------------------------
Author: Bernd Hufmann
Date: 2015-01-16 15:01:13.000000000
Message: 
Patch Set 3: Code-Review-1

(3 comments)

I tested it with hex and octal number and it works. I have some comments though.
Line:151, org.eclipse.tracecompass.tmf.core/src/org/eclipse/tracecompass/tmf/core/filter/model/TmfFilterCompareNode.java -> In my CTF test trace I have a field of type CTFIntegerField. The resolve returns a String generated by CTFIntegerField.toString(). So what happens below, value is not a instance of Number and we need to parse the String to figure out the type.

Moreover, I expected that value would be of type Integer here, i.e. resolve would provide the correct type. Something doesn't add up.

Line:158, org.eclipse.tracecompass.tmf.core/src/org/eclipse/tracecompass/tmf/core/filter/model/TmfFilterCompareNode.java -> Why do we always compare as double?
In one of my tests the fValueNumber is Long. If we compare as double it might not give us the expected result because of the loss of precission.

Line:163, org.eclipse.tracecompass.tmf.core/src/org/eclipse/tracecompass/tmf/core/filter/model/TmfFilterCompareNode.java -> Here too. If fValueNumber is a Long and Long.decode creates a long you should not convert it to double.

----------------------------------------------------------------------------------------------------------------------
Author: Patrick Tasse
Date: 2015-01-17 00:03:56.000000000
Message: 
Patch Set 3:

(3 comments)
Line:151, org.eclipse.tracecompass.tmf.core/src/org/eclipse/tracecompass/tmf/core/filter/model/TmfFilterCompareNode.java -> TmfEventFieldAspect resolves to the String returned by ITmfEventField.getFormattedValue(). I would like to tackle this in a separate patch.

Line:158, org.eclipse.tracecompass.tmf.core/src/org/eclipse/tracecompass/tmf/core/filter/model/TmfFilterCompareNode.java -> We will now compare as double only if at least one of the values is a double (or float).

Line:163, org.eclipse.tracecompass.tmf.core/src/org/eclipse/tracecompass/tmf/core/filter/model/TmfFilterCompareNode.java -> Done

----------------------------------------------------------------------------------------------------------------------
Author: Bernd Hufmann
Date: 2015-01-19 15:21:43.000000000
Message: 
Patch Set 3:

(1 comment)
Line:151, org.eclipse.tracecompass.tmf.core/src/org/eclipse/tracecompass/tmf/core/filter/model/TmfFilterCompareNode.java -> Ok

----------------------------------------------------------------------------------------------------------------------

======================================================================================================================
DESCRIPTION:

MB-46740: Limit the size of ActiveStream::readyQ

Before this patch the ActiveStream Task pulls all the checkpoint
outstanding items for cursor and pushes them into the Stream::readyQ.

That behaviour is the reason why the allocation in readyQ can take a
relevant chunk of the BucketQuota. High allocations in the readyQ have
been observed multiple times, eg MB-53590 as one of the most recent.

This patch changes the ActiveStream Task behaviour to limiting to
checkpoint_max_size_bytes the size of the snapshot generated by
cursor-move and pushed into the readyQ.

Given that the ActiveStream frontend pulls from checkpoint only when
the readyQ is empty (ie, all ready items streamed to the DCP client),
then checkpoint_max_size_bytes is the new theretical size limit for
each stream readyQ.

As usual for checkpoint consumers, the actual size of what is returned
from CM can vary from the theretical limit. That is because (for DCP in
particular) CM needs to generate consistent snapshots that can be
greater than checkpoint_max_size_bytes.

Eg in a case were
  (a) Cursor moves to the end of its current checkpoint -> total
      total snapshot size just below checkpoint_max_size_bytes
  (b) Cursor jumps into the next checkpoint (if any) and pulls
      everything from there too
, then Task would push to the readyQ up to 2 full checkpoints.

Just for making an example, in a scenario like:
  - BucketQuota = 1GB
  - checkpoint_memory_ratio = 30% of BucketQuota = 300MB
  - max_checkpoints = 10
  - num_vbuckets = 64
  - 2 nodes, 1 replica

, then before this change the allocation in the stream's readyQ(s) on a
single DCP Producer can grow up tp 300MB, as nothing's preventing the
ActiveStream Task from pulling a full CM and pushing all items into
readyQ(s).

While with this change:
  - checkpoint_max_size_bytes = CMQuota / max_checkpoints /
      num_vbuckets ~ 480KB
  - single readyQ = 2 * checkpoint_max_size_bytes = 960KB
  - 32 readyQ(s) per node -> ~ 30MB in total

Change verified on tests in MB-53590 (bulk-load via restore). The
baseline runs suffer from uncapped allocations in the Stream::readyQ
that cause memcacahed continously jumping in/out TempOOM phases.
Test repetition on this change (toy run) shows the memcached mem-usage
never crossing the HWM. Result is:
 - No TempOOMs
 - Ingestion throughput gets a 3x boost
 - Overall improved memory control allows to end the test at
   ActiveRR=12% (rather than 0% at baseline)
See MB-53590 for details.

Change-Id: Id4ecee911550834d209434bbf76480f73fae32fd

======================================================================================================================
COMMENTS
======================================================================================================================
Author: Paolo Cocchi
Date: 2022-10-04 07:14:21.000000000
Message: 
Uploaded patch set 5.
----------------------------------------------------------------------------------------------------------------------
Author: Build Bot
Date: 2022-10-04 07:41:03.000000000
Message: 
Patch Set 5: Verified-1 Code-Review-1

Build Failed 

https://cv.jenkins.couchbase.com/job/kv_engine-clang_format_9/20084/ : FAILURE

<p>clang-format suggested the following changes:

<pre>
cat <<"EOF" | patch -p1
diff --git a/engines/ep/tests/module_tests/dcp_stream_test.cc b/engines/ep/tests/module_tests/dcp_stream_test.cc
index 65ea89b27..0250c8666 100644
--- a/engines/ep/tests/module_tests/dcp_stream_test.cc
+++ b/engines/ep/tests/module_tests/dcp_stream_test.cc
@@ -4713,7 +4713,7 @@ TEST_P(SingleThreadedActiveStreamTest, ReadyQLimit) {
 
     const auto value = std::string(checkpointMaxSize / 2, &#39;v&#39;);
     size_t numItems = 6;
-    for (size_t i=0; i&lt;numItems; ++i) {
+    for (size_t i = 0; i &lt; numItems; ++i) {
         store_item(vbid, makeStoredDocKey(&quot;key&quot; + std::to_string(i)), value);
     }
     ASSERT_EQ(numItems, vb.getHighSeqno());
@@ -4731,7 +4731,7 @@ TEST_P(SingleThreadedActiveStreamTest, ReadyQLimit) {
     // At each run the task is allowed to push checkpoint_max_size_bytes into
     // the readyQ. In the scenario under test that means 1 full checkpoint at a
     // time.
-    for (size_t i=0; i&lt;numCheckpoints; ++i) {
+    for (size_t i = 0; i &lt; numCheckpoints; ++i) {
         stream-&gt;nextCheckpointItemTask();
 
         ASSERT_EQ(3, readyQ.size());

EOF
</pre> ( https://cv.jenkins.couchbase.com/job/kv_engine-clang_format_9/20084/ )

https://cv.jenkins.couchbase.com/job/kv_engine-clang_tidy-master/20852/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine-windows-master/49925/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine-clang_analyzer-master/41946/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine.libFuzzer/job/master/10567/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine.macos/job/master/22243/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine.linux-CE/job/master/22839/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine.threadsanitizer/job/master/24078/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine.ASan-UBSan/job/master/31253/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine.aarch64-linux/job/master/10667/ : SUCCESS

https://cv.jenkins.couchbase.com/job/kv_engine.linux/job/master/23236/ : SUCCESS
----------------------------------------------------------------------------------------------------------------------

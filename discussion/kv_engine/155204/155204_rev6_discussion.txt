======================================================================================================================
DESCRIPTION:

MB-45026: Expelling doesn't remove the checkpoint_start item

A good amount of logic around checkpoint assumes the invariant that
the checkpoint_start item always exists in Checkpoint, same as the
empty-item.

When we implemented item-expel we broke that invariant. Expel may remove
the checkpoint_start item because it always assumes that it has to
remove all items that share the same seqno.
We still keep that logic at "expel", but not for the checkpoint_start
item that stays untouched now.

The change requires to preserve our cursor-registering logic by updating
the Checkpoint::getLowSeqno() logic accordingly to the new expel
behaviour.

Change-Id: Ic9dd5534b8888a416f93745e42b13ba1aaf3d324

======================================================================================================================
COMMENTS
======================================================================================================================
Author: Paolo Cocchi
Date: 2021-06-08 07:18:17.000000000
Message: 
Uploaded patch set 6.
----------------------------------------------------------------------------------------------------------------------
Author: Build Bot
Date: 2021-06-08 07:58:09.000000000
Message: 
Patch Set 6: Verified+1

Build Successful 

http://cv.jenkins.couchbase.com/job/kv_engine-clang_format_9/8178/ : SUCCESS

http://cv.jenkins.couchbase.com/job/kv_engine-clang_tidy-master/9580/ : SUCCESS

http://cv.jenkins.couchbase.com/job/kv_engine-windows-master/36533/ : SUCCESS

http://cv.jenkins.couchbase.com/job/ming-test2/124/ : SUCCESS

http://cv.jenkins.couchbase.com/job/kv_engine-clang_analyzer-master/31220/ : SUCCESS

http://cv.jenkins.couchbase.com/job/kv_engine.macos/job/master/10225/ : SUCCESS

http://cv.jenkins.couchbase.com/job/kv_engine.linux/job/master/11303/ : SUCCESS

http://cv.jenkins.couchbase.com/job/kv_engine.linux-CE/job/master/11155/ : SUCCESS

http://cv.jenkins.couchbase.com/job/kv_engine.threadsanitizer/job/master/11575/ : SUCCESS

http://cv.jenkins.couchbase.com/job/kv_engine.ASan-UBSan/job/master/19158/ : SUCCESS
----------------------------------------------------------------------------------------------------------------------
Author: Dave Rigby
Date: 2021-06-09 12:58:20.000000000
Message: 
Patch Set 6: Code-Review-1

(2 comments)
Line:532, engines/ep/src/checkpoint.cc -> This should probably explicitly throw a std::logic_error or similar exception given this isn't an invariant on the system; more the responsibility of the caller.

Line:510, engines/ep/src/checkpoint.h -> I'd be tempted to rename this - to something like getLowestPresentSeqno / getLowNonExpelledSeqno - that way it's more explicit about what it means (without having to read the method documentation).

----------------------------------------------------------------------------------------------------------------------
Author: Paolo Cocchi
Date: 2021-06-10 07:59:19.000000000
Message: 
Patch Set 6:

(2 comments)
Line:532, engines/ep/src/checkpoint.cc -> Done

Line:510, engines/ep/src/checkpoint.h -> Eheh I've tried too but look at what happens:

getLowestPresentSeqno -> good name for the case where expel has run as we pick up the first item after ckpt_start, but not true for the other case

getLowNonExpelledSeqno -> opposite, in theory not a good name for when expel hasn't run as we pick the ckpt_start seqno

The problem with the naming is generated by the fact that the function returns 2 different quantities depending on the case:

(1) Expel hasn't run -> low-seqno is the seqno of checkpoint_start
    So imagine you have a checkpoint like [e:1 cs:1 m:6). No Expel, seqnos 2->5 have been deduped. The function returns 1, while the "low-seqno" that you would expect is 6.

(2) Expel has run -> low-seqno is the seqno of the first item after the checkpoint_start
    Again [e:1 cs:1 m:6), here 2->5 were expelled. The function returns 6, which is definitely what you expect.

(1) is just an optimization. We could collapse both cases to (2), but we would end up backfilling more, eg consider again the same example where expel hasn't run (so the seqno-gap is caused by normal dedup):

    [e:1 cs:1 m:6)
    stream-req(lastRecvSeqno=4)

by (1):
    low-seqno=1
    CM:::registerCursorBySeqno() -> lastRecvSeqno(4)>=low-seqno(1) -> in-memory

by (2):
    low-seqno=6
    CM:::registerCursorBySeqno() -> lastRecvSeqno(4)<low-seqno(6) -> backfill

So if you have a reasonably short name for embedding the semantic above I'm happy to use it ! I could't find it so far :D

----------------------------------------------------------------------------------------------------------------------
Author: Dave Rigby
Date: 2021-06-10 08:46:57.000000000
MISMATCHED INLINE COMMENT
Line:510, engines/ep/src/checkpoint.h -> What about something more direct - i.e. "getMinimumCursorSeqno" or similar?
----------------------------------------------------------------------------------------------------------------------
Author: Paolo Cocchi
Date: 2021-06-16 12:53:39.000000000
MISMATCHED INLINE COMMENT
Line:510, engines/ep/src/checkpoint.h -> Ack
----------------------------------------------------------------------------------------------------------------------

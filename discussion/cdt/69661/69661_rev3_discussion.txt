======================================================================================================================
DESCRIPTION:

Bug 490475. Support the evaluation of C++14 constexpr functions

Change-Id: I05029f26b6d33cbeeab8138a270b38c4018b64b5
Signed-off-by: Toni Suter <tsuter@hsr.ch>
Signed-off-by: Silvano Brugnoni <sbrugnon@hsr.ch>

======================================================================================================================
COMMENTS
======================================================================================================================
Author: Toni Suter
Date: 2016-05-06 13:42:03.000000000
Message: 
Uploaded patch set 3.
----------------------------------------------------------------------------------------------------------------------
Author: CI Bot
Date: 2016-05-06 13:42:10.000000000
Message: 
Patch Set 3:

Build Started https://hudson.eclipse.org/cdt/job/cdt-verify/5142/
----------------------------------------------------------------------------------------------------------------------
Author: CI Bot
Date: 2016-05-06 13:43:12.000000000
Message: 
Patch Set 3: Code-Review-1 Verified-1

Build Failed 

https://hudson.eclipse.org/cdt/job/cdt-verify/5142/ : FAILURE
----------------------------------------------------------------------------------------------------------------------
Author: Nathan Ridge
Date: 2016-05-11 07:29:21.000000000
Message: 
Patch Set 3:

(31 comments)
Line:176, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPDeferredFunction.java -> If you split out getConstructorChainExecution() into an ICPPComputableConstructor interface as I suggest below, then this override will not be necessary.

Line:25, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFieldSpecialization.java -> Now that we have a CPPVariableSpecialization, this should be refactored to inherit from it.

Line:49, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFieldTemplatePartialSpecialization.java -> Better: 

  return ((ICPPFieldTemplate) getPrimaryTemplate()).getFieldPosition();

Line:770, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunction.java -> As with function body executions, we probably shouldn't compute constructor chain executions if the function is not constexpr.

Line:777, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunction.java -> In Java 7, you can write "new ArrayList<>()" here.

Line:783, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunction.java -> And "new Pair<>(fieldMember, memberEval)" here.

Line:788, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunction.java -> What if the constructor call uses the {} syntax? Then the initializer would be an ICPPASTInitializerList.

Line:360, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunctionSpecialization.java -> Doesn't the execution need to be instantiated, the way the return expression's evaluation is in getReturnExpression()?

Line:377, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunctionSpecialization.java -> Likewise here?

Line:49, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPImplicitConstructor.java -> Instead of overriding this method, pass the correct value in for the "isConstexpr" parameter when constructing the CPPImplicitConstructor.

Line:30, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPTemplateParameterMap.java -> Few comments about this:

  - Please add a comment saying what is being mapped
    (looks like function parameters).

  - Since the objects being mapped are function parameters,
    I don't think this belongs in the template parameter map.
    InstantiationContext would be a better place.

  - Since this is only used in a fairly specific situation,
    you may want to implement an optimization where the
    HashMap object is only created the first time you
    call putBinding().

Line:241, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPVariable.java -> If "nestedType instanceof ICPPClassType", initialValue isn't used at all; let's avoid computing it in that case.

Line:285, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPVariable.java -> Please avoid calling findImplicitlyCalledConstructor() twice (once in hasImplicitlyCalledCtor(), and once here). It's an expensive operation.

Line:286, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPVariable.java -> I notice that in some other places where we create an EvalConstructor, we use the one-argument form of EvalConstructor.extractArguments(). Is there a reason for the difference?

Line:36, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/ICPPComputableFunction.java -> It may be worth introducing an ICPPComputableConstructor interface inheriting from ICPPComputableFunction, and declaring this method in ICPPComputableConstructor. (And then, for example, only CPPConstructor would implement ICPPComputableConstructor, not CPPFunction).

Line:19, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ActivationRecord.java -> Please add a comment describing the purpose of the class. (It's described pretty well in the comment above ICPPEvaluation.computeForFunctionCall(), but a reader may not know to look there.)

Line:969, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> Why can't this be handled as a case in createSpecalization()?

Line:973, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> What if the value changes while the type remains the same?

For example:

  template <int N>
  void foo()
  {
    int var = N;
  }

Here, the type of the variable specialization is the same as the type of the original variable, but the initial value is different.

Line:978, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> What if the variable is a variable template? Do we not need a CPPVariableTemplateSpecialization class now? (Compare the corresponding code for fields in createSpecialization()).

Line:1015, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> What about local classes? (We can handle those in a follow-up, but please add a TODO comment about it.)

Line:1086, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> (Enumerations can be local to a function, too.)

Line:1125, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> This declaration was split across two lines on purpose, to respect the 110-character width limit. Please preserve it, here and elsewhere.

Line:1278, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPVisitor.java -> We can probably remove the code that does the same thing before the getUltimateTypeUptoPointers() call - shouldn't need to check twice.

Line:166, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> There was some logic here to simplify && and || in cases where the first operand is known, even if the second operand is dependent. Why was it removed?

Line:163, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> As mentioned elsewhere, please do not invent AST nodes to call EvalID.create(). Use EvalBinding instead.

Line:174, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> We should cache the overload evaluation, similar to how the overload itself is cached.

Line:432, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Throughout this function, propagate context.getPoint() into calls like this instead of passing "null"

Line:461, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> context.getPoint() should be propagated into here instead of passing null

Line:466, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Same here

Line:473, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Is EvalCompositeAccess only used for arrays? If so, can we rename it to EvalArrayAccess so it's clearer? (If not, we need an extra check here.)

Line:99, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> Please explain, in a comment, what this function does, and what the two components of the pair signify. It's not at all obvious to a reader. (I still haven't figured it out, and I've been looking at this code for a while.)

----------------------------------------------------------------------------------------------------------------------
Author: Nathan Ridge
Date: 2016-05-12 06:50:52.000000000
Message: 
Patch Set 3:

(13 comments)
Line:31, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompositeAccess.java -> Please add a comment describing what sorts of "composites" this is used for.

Line:49, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompositeAccess.java -> This is too easily confused with getValue(IASTNode). Can we call it "getTargetEvaluation()" instead?

Line:65, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompositeAccess.java -> Was this meant to be isValueDependent()?

Line:133, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompositeAccess.java -> Probably better to use parent.getTemplateDefinition().

Line:33, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompoundStatementExpression.java -> Now that we can represent statement executions, this evaluation should store the executions of the statements that come before the last one in the statement-expression. Feel free to leave this for later and just add a TODO comment about it.

Line:58, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Please make this static, so it doesn't take up space in every EvalConstructor instance. (Even better would be to remove it altogether, but I can't think right now of how to replace it use.)

Line:83, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> This can be type-dependent if "type" is dependent, or if "arguments" are type-dependent. Compare EvalTypeId.isTypeDependent().

Line:88, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Similarly, compare EvalTypeId.isValueDependent().

Line:98, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Why not "type"?

Line:103, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> I guess the idea here is that you need to call computeForFunctionCall() on this before you can get its value? This might be problematic, but I'm not sure; we can try it.

Also, EvalFixed.INCOMPLETE.getValue() can be expressed more directly as IntegralValue.ERROR.

Line:259, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> This should probably be implemented. Use EvalTypeId as guidance.

Line:264, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Likewise.

Line:307, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Shouldn't the "impliedObjectType" parameter of the EvalFunctionSet constructor be "newType" rather than "null"?

----------------------------------------------------------------------------------------------------------------------
Author: Nathan Ridge
Date: 2016-05-13 05:21:09.000000000
Message: 
Patch Set 3:

(62 comments)
Line:112, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> I assume "record" here is the activation record of the function in which the constructor is called (as opposed to the activation record of the constructor itself, which we create below). Could we rename the parameter to make this clearer?

Line:118, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Any reason we can't just use "constructedObject" as the evaluation representing the implicit this? That would get us one step closer to not needing the invented AST node.

Line:131, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Shouldn't the activation record used to evaluate the base class initializer be "activationRecord" rather than "record"?

Line:132, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Throughout this function, pass "context.getPoint()" instead of "null" for IASTNode parameters.

Line:137, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Two comments about this:

  1) I think it would be easier to understand to just inline this,
     rather than constructing a temporary EvalCompositeAccess:

     constructedObject.getValue(context.getPoint()).set(
             fieldPos, baseClassValues[fieldPos]);

  2) We're going to have the same problem with multiple inheritance,
     as in CompositeValue.create(ICPPClassType).

Line:164, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> EvalFunctionCall.computeForFunctionCall():

  - evaluates the arguments again
  - creates yet another activation record (inside 
    evaluateFunctionBody())

Is either of these necessary?

Line:175, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Linear searching through a list of pairs is an indication that you should probably be using a map instead.

Line:195, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> After you modify CPPFunctionSpecialization.getConstructorChainExecution() to instantiate the execution as suggested in a previous comment, instantiating it here will no longer be necessary.

Line:211, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Inline paramCount into this condition. That way, if args.length is not 1, we don't call constructor.getParameters().

Line:258, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> This function will become unnecessary if you instantiate in CPPFunctionSpecialization.getFunctionBodyExecution().

Line:304, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> Why are we executing it a second time?

Line:306, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> execReturn

Line:310, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> Why do this at all? Why do it for EvalBindings only? (I realize that either not doing it at all, or doing it for all evaluation types, breaks tests, but I don't understand why. A comment would be helpful.)

Line:325, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> The "getOverload(point) == null" condition is redundant. We already know it's null.

Line:354, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> Add a comment saying why this is 1 (because the first argument is the function's evaluation).

Line:429, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalMemberAccess.java -> Can we use this.getTemplateDefinition() here?

Line:436, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalMemberAccess.java -> And here?

Line:20, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Add a comment saying that we can only have position != 0 if the EvalReference has a referredSubValue, not a referredBinding.

Line:26, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Call the third parameter "templateDefinition".

Line:30, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Likewise.

Line:66, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Should this also null out referredBinding?

Line:75, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Wouldn't position == numberOfValues() also make it out of range?

Line:80, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> I find it strange that the value of a pointer is considered to be its offset into the array it points into.

Line:26, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Add a comment saying that there's either a referredBinding or a rederredSubValue, but not both.

Line:28, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Call the third parameter "templateDefinition".

Line:38, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Likewise.

Line:42, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> This line is redundant, object fields are initialized to null automatically.

Line:84, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> As with EvalCompositeAccess.getValue(), I think this would be better named getTargetEvaluation().

Line:119, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Why only for EvalReference?

Line:137, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> So instantiation loses the EvalReference wrapper, and gives you just the target value - is that intentional?

Line:150, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalTypeId.java -> Don't character types also value-initialize to zero?

Line:296, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalTypeId.java -> Since we're not using "args", let's do this check before computing "args".

Line:395, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUnary.java -> Use EvalBinding

Line:447, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUnary.java -> null -> context.getPoint()

Line:460, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUnary.java -> Likewise.

Line:33, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> Exr -> Expr

Line:34, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> null -> context.getPoint()

Line:40, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> null -> context.getPoint()

Line:90, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> This function has no callers.

Line:33, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecConstructorChain.java -> It's probably a mistake to ever try to instantiate this (the constructor should be instantiated instead, and the constructor chain of the constructor specialization queried). Can we throw UnsupportedOperationException here?

Line:81, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecDeclarator.java -> null -> context.getPoint() throughout this function

Line:113, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecDeclarator.java -> null -> context.getPoint()

Line:126, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecDeclarator.java -> null -> context.getPoint()

Line:41, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecDo.java -> Does this "continue" do anything (different from just reaching the end of the loop body)?

Line:57, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Throughout this file, null -> context.getPoint()

Line:105, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> This can be static like isEqual().

Line:114, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> This too.

Line:116, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Use EvalUnary with the prefix-increment operator. All iterators are required to provide that, while only random-access iterators are required to define a binary plus operator.

Line:129, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Use EvalBinding

Line:136, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Please move this function to SemanticUtil.java.

Line:173, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> This is not the correct way to instantiate the begin and end functions. The reason is that, if the range type is dependent, argument-dependent lookup may find different begin and end functions to call after instantiation.

Here's an outline of how to do it correctly:

  - Construct EvalFunctionCall evaluations representing the
    invocations of the begin and end functions with the
    range as the argument.

  - Instantiate the EvalFunctionCalls. This will perform the
    ADL, if appropriate, in EvalFunctionSet.resolveFunction().

  - Query the instantiated function bindings from the
    instantiated EvalFunctionCalls.

Feel free to leave implementing this for later and just add a TODO comment.

(An alternative way to implement range-based for loops is to "lower" them to the form described in the standard, built using the appropriate evaluations and executions. Then the above instantiations will fall out from that automatically.)

Line:37, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecSwitch.java -> Switch statements cannot contain "continue".

Line:78, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecSwitch.java -> executionsDidChange

Line:855, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/SemanticUtil.java -> "clause" is null here - use "init" instead.

Line:87, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/TypeTraits.java -> This third property is not being checked.

Line:199, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/TypeMarshalBuffer.java -> You'll also need to increment the PDOM version in PDOM.java (increment the major version in each of MIN_SUPPORTED_VERSION, MAX_SUPPORTED_VERSION, and DEFAULT_VERSION).

Line:30, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPField.java -> Use PDOMCPPVariable.RECORD_SIZE instead of "ANNOTATIONS + 1".

Line:57, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPFieldInstance.java -> Why not ((ICPPField) getSpecializedBinding()).getFieldPosition()?

Line:55, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPFieldTemplate.java -> PDOMCPPFieldTemplates should store their field position just like PDOMCPPFields.

Line:79, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPFieldTemplatePartialSpecialization.java -> ((ICPPField) getPrimaryTemplate()).getFieldPosition()

Line:91, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPFunction.java -> We may want to consider optimizing this, so that we don't take up 12 bytes of space in every function including non-constexpr ones. We can leave that for a follow-up.

Line:23, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPVariableInstance.java -> This import is not used.

----------------------------------------------------------------------------------------------------------------------
Author: Nathan Ridge
Date: 2016-05-13 05:23:11.000000000
Message: 
Patch Set 3:

All right, I've finally finished going over the patch, so that should be all the comments! I know there are a lot of comments, but a lot of them are trivial to address, and a lot of others are just me asking questions because I don't fully understand the code yet.

Next, I will install a version of CDT with this patch applied, and open some large codebases to see how it handles them.
----------------------------------------------------------------------------------------------------------------------
Author: Toni Suter
Date: 2016-06-05 10:34:33.000000000
Message: 
Patch Set 3:

(49 comments)
Line:49, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFieldTemplatePartialSpecialization.java -> Done

Line:770, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunction.java -> Done

Line:777, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunction.java -> Done

Line:783, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunction.java -> Done

Line:241, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPVariable.java -> Done

Line:285, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPVariable.java -> Done

Line:19, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ActivationRecord.java -> Done

Line:163, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Done

Line:432, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Done

Line:461, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Done

Line:466, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Done

Line:49, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompositeAccess.java -> Done

Line:65, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompositeAccess.java -> Done

Line:133, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompositeAccess.java -> Done

Line:325, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> Done

Line:354, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> Done

Line:429, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalMemberAccess.java -> Done

Line:436, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalMemberAccess.java -> Done

Line:26, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Done

Line:30, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Done

Line:75, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Silvano has written this code, so I am not absolutely sure, but I think the reason is that in a constexpr context it is allowed to point to one past the last element as long as you don't dereference it. Example:

constexpr int f() {
	int arr[2]{};
	int* ptr = arr;          // refers to arr[0] => valid
	ptr++;			// refers to arr[1] => valid
	ptr++;			// one past end => still valid
	ptr++;			// illegal in a constexpr context
	return 0;
}
constexpr int x = f();

Line:26, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Done

Line:28, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Done

Line:38, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Done

Line:42, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> This doesn't work because referredBinding is final. If you want I can change that, but I think it makes sense to make it final.

Line:395, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUnary.java -> Done

Line:447, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUnary.java -> Done

Line:460, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUnary.java -> Done

Line:33, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> Done

Line:34, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> Done

Line:40, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> Done

Line:90, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> Done

Line:81, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecDeclarator.java -> Done

Line:113, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecDeclarator.java -> Done

Line:126, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecDeclarator.java -> Done

Line:57, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Done

Line:105, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Done

Line:114, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Done

Line:129, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Done

Line:136, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Done

Line:37, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecSwitch.java -> I think it's possible, if the switch statement is inside a loop. For example:

for(int i = 0; i < 10; i++) {
	switch(i) {
		case 0:
		case 1:
		case 2:
		case 3:
			std::cout << "skipping " << i << '\n';
			continue;
	}
	std::cout << i << '\n';
}

Line:78, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecSwitch.java -> Done

Line:855, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/SemanticUtil.java -> Done

Line:199, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/TypeMarshalBuffer.java -> Done

Line:30, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPField.java -> Done

Line:57, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPFieldInstance.java -> Done

Line:55, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPFieldTemplate.java -> Done

Line:79, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPFieldTemplatePartialSpecialization.java -> Done

Line:23, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPVariableInstance.java -> Done

----------------------------------------------------------------------------------------------------------------------
Author: Nathan Ridge
Date: 2016-07-20 00:21:12.000000000
Message: 
Patch Set 3:

(3 comments)

Sorry for the very late reply. I hope to spend some time now continuing to test the patch on some large codebases to flush out any remaining issues, and hopefully then we can commit this soon.
Line:75, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> OK, thank you for explaining. Perhaps this is worth mentioning in a comment.

Line:42, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Thanks, it's fine as it is then.

Line:37, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecSwitch.java -> You're right, I wasn't thinking clearly when I wrote this comment.

----------------------------------------------------------------------------------------------------------------------
Author: Toni Suter
Date: 2016-08-27 18:10:36.000000000
Message: 
Patch Set 3:

(16 comments)
Line:25, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFieldSpecialization.java -> Done

Line:1278, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPVisitor.java -> Done

Line:58, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:83, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:88, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:98, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:112, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> I renamed the two variables to 'callSiteRecord' and 'localRecord'.

Line:118, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:131, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:132, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:211, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:259, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:264, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:84, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Done

Line:296, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalTypeId.java -> Done

Line:41, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecDo.java -> You're right. This doesn't do anything. I'll remove it.

----------------------------------------------------------------------------------------------------------------------
Author: Nathan Ridge
Date: 2016-09-04 06:47:19.000000000
Message: 
Patch Set 3:

(9 comments)

I addressed some of the remaining comments from Patch Set 3:

https://github.com/tonisuter/evaluator-cdt/pull/13
Line:176, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPDeferredFunction.java -> (Since I wrote this comment, CPPDeferredConstructor was introduced, so while CPPDeferredFunction no longer needs an override like this, CPPDeferredConstructor still does.)

Line:788, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunction.java -> Done

Line:360, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunctionSpecialization.java -> Things worked because the execution was being instantiated in EvalFunctionCall.evaluateFunctionBody(). However, I believe it's better to do the instantiation in CPPFunctionSpecialization.getFunctionBodyExecution() and PDOMCPPFunctionSpecialization.getFunctionBodyExecution(), so I moved it there.

Line:377, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPFunctionSpecialization.java -> I left this one as a TODO, since instantiation for constructor chain executions isn't implemented yet to begin with.

Line:49, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPImplicitConstructor.java -> I tried this, but found that calling TypeTraits.isLiteralClass() in some of the places where a CPPImplicitConstructor is constructed (CPPClassScope.createImplicitMembers()) is too early (not enough stuff is resolved yet). So this is fine as is.

Line:30, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPTemplateParameterMap.java -> Done

Line:286, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/CPPVariable.java -> I think the desired logic is:

  - If we know what constructor call we'll be expanding
    the arguments into, use the two-argument form that
    takes the constructor.

  - Otherwise, use the one-argument form.

Accordingly, I've adjusted the call site in CPPFunction.getConstructorChainExecution(IASTNode) to use the two-argument form.

That said, I think there are a number of bugs in our handling of initializer lists that may require us to re-think this part of the code. However, that can be left as a follow-up.

Line:36, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/ICPPComputableFunction.java -> I ended up moving the method to ICPPConstructor itself, since all implementations of ICPPConstructor would have implemented ICPPComputableConstructor as well.

It turned out to be a bit more annoying than I initially envisioned, because of the way our hierarchies work: e.g. PDOMCPPConstructor and PDOMCPPConstructorTemplate have a common base class that implements ICPPComputableFunction (that being PDOMCPPFunction), but not one that implements ICPPConstructor; as a result, I had to duplicate some implementations of the method. However, I think it was worth it for the index size reduction (not storing an empty constructor execution field for function records that are not constructors).

Line:33, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecConstructorChain.java -> Looking at this again, my suggestion doesn't make sense. When you query the constructor chain of the constructor specialization, the constructor specialization takes the original constructor's chain and instantiates it (at least, that's what it's supposed to do; that's currently not implemented, as commented elsewhere).

So the actual instantiation work does happen here, and this needs to be implemented. So, instead of throwing an UnsupportedOperationException, I just added a TODO comment.

----------------------------------------------------------------------------------------------------------------------
Author: Nathan Ridge
Date: 2016-09-15 02:54:23.000000000
Message: 
Patch Set 3:

(32 comments)

I addressed the remaining review comments on Patch Set 3:

https://github.com/tonisuter/evaluator-cdt/pull/14
Line:969, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> Now that I've but fBindingsMap (renamed to fInstantiatedLocals) into InstantiationContext, merging createVariableSpecialization() into createSpecialization() would require either propagating InstantiationContext through createSpecialization(), or getting rid of fInstantiatedLocals (which I plan to do anyways). Added a TODO.

Line:973, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> Done

Line:978, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> It turns out we don't need a CPPVariableTemplateSpecialization, because variable templates cannot occur at local scope.

Line:1015, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> Done

Line:1086, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> Done

Line:1125, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java -> Done

Line:166, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Restored.

Line:174, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> Done

Line:473, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalBinary.java -> EvalCompositeAccess is definitely used for composite values other than arrays, such as structures. However, perhaps we don't need an extra check here because it's only wrapped into an EvalPointer in the context of a pointer to an array? I'm not sure; I added a TODO comment for now.

Line:31, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompositeAccess.java -> Done

Line:33, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalCompoundStatementExpression.java -> Done

Line:103, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Yes, it looks like an EvalConstructor is never used to directly represent the evaluation of an expression in the source code (i.e. the return value of IASTExpression.getEvaluation() is never an EvalConstructor). Rather, EvalConstructors are created while evaluating other evaluations like EvalTypeId.

Line:137, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:164, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> I added a TODO comment asking this question. Toni, if you know the answer, please feel free to edit as appropriate.

Line:175, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:195, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:307, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalConstructor.java -> Done

Line:258, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> Done

Line:304, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> The convention seems to be that if a function exits by returning, ExecCompoundStatement.executeForFunctionCall() returns the ExecReturn, which then has to be executed separately. This seems a bit strange to me, but I guess it's fine.

Line:306, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> Done

Line:310, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalFunctionCall.java -> I still don't understand this. I left a TODO comment about it. Toni, if you know the answer please explain.

Line:20, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Done

Line:66, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Done

Line:80, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalPointer.java -> Added a TODO to investigate this later.

Line:119, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Added TODO about this. Again, Toni, if you know the answer please explain

Line:137, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalReference.java -> Added a TODO about this

Line:150, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalTypeId.java -> Yes. I see we have a test case for this, IntegralValueTests.testCharDefaultValue(). I think it's wrong - gcc and clang both accept that code, and give the variable the value 0.

Line:99, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/EvalUtil.java -> Done

Line:116, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Done

Line:173, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/ExecRangeBasedFor.java -> Added a TODO for now

Line:87, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/TypeTraits.java -> Added a TODO about it

Line:91, core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/pdom/dom/cpp/PDOMCPPFunction.java -> I've moved constructor chains to be in constructor records only. I also think we can remove RETURN_EXPRESSION as a folow-up, since FUNCTION_BODY supersedes it. I think that's good enough in terms of space optimization.

----------------------------------------------------------------------------------------------------------------------
Author: Gerrit Code Review
Date: 2016-09-16 07:10:05.000000000
Message: 
Change has been successfully merged into the git repository by Nathan Ridge
----------------------------------------------------------------------------------------------------------------------
